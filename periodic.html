<!DOCTYPE html>
<html lang="en">
<head>
  <title>Assignment - Periodic (CSV Data)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />

  <style>
    * { box-sizing: border-box; font-family: Helvetica, Arial, sans-serif; }
    body { margin: 0; overflow: hidden; background: #000; color: #fff; }

    #info {
      position: absolute; top: 10px; width: 100%;
      text-align: center; z-index: 2; user-select: none;
      pointer-events: none; opacity: 0.75; font-size: 13px;
    }

    #legend {
      position: absolute; top: 12px; left: 12px; z-index: 3;
      padding: 10px 12px; border-radius: 10px;
      border: 1px solid rgba(127,255,255,0.35);
      background: rgba(0,0,0,0.45); font-size: 13px; user-select: none;
    }
    #legend .r { color: #ff3b30; }
    #legend .o { color: #ff9500; }
    #legend .g { color: #34c759; }

    #container { position: absolute; inset: 0; }

    #menu {
      position: absolute; bottom: 20px; width: 100%;
      text-align: center; z-index: 3;
    }
    button {
      color: rgba(127,255,255,0.85);
      background: rgba(0,0,0,0.2);
      outline: 1px solid rgba(127,255,255,0.75);
      border: 0; padding: 8px 14px; margin: 0 6px;
      border-radius: 8px; cursor: pointer; font-weight: 600;
      letter-spacing: 0.5px;
    }
    button:hover { background-color: rgba(0,255,255,0.25); }
    button:active { color: #000; background-color: rgba(0,255,255,0.75); }

    /* Tiles */
    .element {
      width: 140px; height: 180px; border-radius: 12px;
      box-shadow: 0 0 12px rgba(0,255,255,0.25);
      border: 1px solid rgba(127,255,255,0.25);
      text-align: center; line-height: normal; cursor: default;
      position: relative; overflow: hidden; backdrop-filter: blur(2px);
    }
    .element:hover {
      box-shadow: 0 0 18px rgba(0,255,255,0.45);
      border: 1px solid rgba(127,255,255,0.55);
    }
    .element .number {
      position: absolute; top: 10px; right: 12px;
      font-size: 12px; color: rgba(255,255,255,0.85); opacity: 0.9;
    }
    .element img.photo {
      position: absolute; top: 14px; left: 50%;
      transform: translateX(-50%);
      width: 54px; height: 54px; border-radius: 999px;
      object-fit: cover; border: 2px solid rgba(255,255,255,0.6);
      background: rgba(0,0,0,0.2);
    }
    .element .symbol {
      position: absolute; top: 78px; left: 10px; right: 10px;
      font-size: 16px; font-weight: 800; color: rgba(255,255,255,0.92);
      text-shadow: 0 0 10px rgba(0,0,0,0.35);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .element .details {
      position: absolute; bottom: 14px; left: 10px; right: 10px;
      font-size: 12px; color: rgba(255,255,255,0.88);
      line-height: 1.35; opacity: 0.95;
    }

    /* Small status */
    #statusBar {
      position: absolute; left: 12px; bottom: 76px; z-index: 3;
      padding: 8px 10px; border-radius: 10px;
      border: 1px solid rgba(127,255,255,0.25);
      background: rgba(0,0,0,0.35);
      font-size: 12px; color: rgba(255,255,255,0.75);
      max-width: 520px;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>
  <div id="legend">
    Net Worth:
    <span class="r">Red &lt; 100K</span> |
    <span class="o">Orange 100K–200K</span> |
    <span class="g">Green &gt; 200K</span>
  </div>

  <div id="info">three.js css3d - periodic table (public CSV data)</div>
  <div id="container"></div>

  <div id="statusBar">Loading CSV…</div>

  <div id="menu">
    <button id="table">TABLE</button>
    <button id="sphere">SPHERE</button>
    <button id="helix">HELIX</button>
    <button id="grid">GRID</button>
    <button id="pyramid">PYRAMID</button>
  </div>

  <!-- IMPORTANT: adjust import paths to match your repo structure -->
  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import TWEEN from 'three/addons/libs/tween.module.js';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';

    // ===========================
    // PUBLIC CSV (so everyone can view without Google login)
    // Use your link:
    const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQnfaQnOekqBUL92EWQZ2Y8dR2DT04CpSmm9m2PLzKJdO9EP5OXulbbwrEcsGSTLyVbmmZz6RXPzx9L/pub?gid=1278840914&single=true&output=csv";
    // ===========================

    const statusBar = document.getElementById("statusBar");

    let camera, scene, renderer, controls;
    const objects = [];
    const targets = { table: [], sphere: [], helix: [], grid: [], pyramid: [] };

    function setStatus(msg) { statusBar.textContent = msg; }

    // ---------- CSV parsing (supports quotes + commas) ----------
    function parseCSV(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        const next = text[i + 1];

        if (c === '"' ) {
          if (inQuotes && next === '"') { // escaped quote
            cur += '"'; i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (c === ',' && !inQuotes) {
          row.push(cur); cur = "";
        } else if ((c === '\n' || c === '\r') && !inQuotes) {
          if (c === '\r' && next === '\n') i++;
          row.push(cur);
          // ignore empty trailing rows
          if (row.some(cell => String(cell).trim() !== "")) rows.push(row);
          row = []; cur = "";
        } else {
          cur += c;
        }
      }
      // last cell
      row.push(cur);
      if (row.some(cell => String(cell).trim() !== "")) rows.push(row);
      return rows;
    }

    function parseNetWorthToNumber(value) {
      if (!value) return 0;
      const cleaned = String(value).replace(/[^\d.]/g, "");
      const num = Number(cleaned);
      return Number.isFinite(num) ? num : 0;
    }

    function netWorthColor(netWorthNum) {
      if (netWorthNum < 100000) return "rgba(255,59,48,0.75)";   // red
      if (netWorthNum <= 200000) return "rgba(255,149,0,0.75)";  // orange
      return "rgba(52,199,89,0.75)";                             // green
    }

    function rowsToObjects(values) {
      if (!values || !values.length) return [];

      const header = values[0].map(h => String(h || "").trim().toLowerCase());
      const findCol = (name) => header.findIndex(h => h.replace(/\s+/g,'') === name);

      // Expect: Name, Photo, Age, Country, Interest, Net Worth
      let idxName = findCol("name");       if (idxName < 0) idxName = 0;
      let idxPhoto = findCol("photo");     if (idxPhoto < 0) idxPhoto = 1;
      let idxAge = findCol("age");         if (idxAge < 0) idxAge = 2;
      let idxCountry = findCol("country"); if (idxCountry < 0) idxCountry = 3;
      let idxInterest = findCol("interest"); if (idxInterest < 0) idxInterest = 4;
      let idxNet = findCol("networth");    if (idxNet < 0) idxNet = 5;

      const out = [];
      for (let r = 1; r < values.length; r++) {
        const row = values[r] || [];
        const name = row[idxName] ?? "";
        if (!String(name).trim()) continue;

        const photo = row[idxPhoto] ?? "";
        const age = row[idxAge] ?? "";
        const country = row[idxCountry] ?? "";
        const interest = row[idxInterest] ?? "";
        const netWorthRaw = row[idxNet] ?? "";
        const netWorthNum = parseNetWorthToNumber(netWorthRaw);

        out.push({
          name: String(name),
          photo: String(photo),
          age: String(age),
          country: String(country),
          interest: String(interest),
          netWorthRaw: String(netWorthRaw),
          netWorthNum
        });
      }
      return out;
    }

    function clearScene() {
      for (const obj of objects) scene.remove(obj);
      objects.length = 0;
      for (const k of Object.keys(targets)) targets[k].length = 0;
    }

    function initThree() {
      camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.z = 3000;

      scene = new THREE.Scene();

      renderer = new CSS3DRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('container').appendChild(renderer.domElement);

      controls = new TrackballControls(camera, renderer.domElement);
      controls.minDistance = 500;
      controls.maxDistance = 6000;
      controls.addEventListener('change', render);

      window.addEventListener('resize', onWindowResize);

      animate();
    }

    function buildTiles(data) {
      clearScene();

      for (let i = 0; i < data.length; i++) {
        const d = data[i];

        const element = document.createElement('div');
        element.className = 'element';
        element.style.backgroundColor = netWorthColor(d.netWorthNum);

        const number = document.createElement('div');
        number.className = 'number';
        number.textContent = String(i + 1);
        element.appendChild(number);

        const img = document.createElement('img');
        img.className = 'photo';
        img.alt = d.name;
        img.src = d.photo || "";
        img.onerror = () => { img.style.display = "none"; };
        element.appendChild(img);

        const symbol = document.createElement('div');
        symbol.className = 'symbol';
        symbol.textContent = d.name;
        element.appendChild(symbol);

        const details = document.createElement('div');
        details.className = 'details';
        details.innerHTML =
          `${d.country || "-"} | Age: ${d.age || "-"}<br>` +
          `${d.interest || "-"}<br>` +
          `${d.netWorthRaw || ""}`;
        element.appendChild(details);

        const objectCSS = new CSS3DObject(element);
        objectCSS.position.x = Math.random() * 4000 - 2000;
        objectCSS.position.y = Math.random() * 4000 - 2000;
        objectCSS.position.z = Math.random() * 4000 - 2000;
        scene.add(objectCSS);

        objects.push(objectCSS);
      }
    }

    function makeTargets_Table() {
      // TABLE: 20 x 10 (requirement)
      for (let i = 0; i < objects.length; i++) {
        const col = (i % 20) + 1;            // 1..20
        const row = Math.floor(i / 20) + 1;  // 1..10+

        const obj = new THREE.Object3D();
        obj.position.x = (col * 140) - 1470; // centered 20 cols
        obj.position.y = -(row * 180) + 990; // centered 10 rows
        targets.table.push(obj);
      }
    }

    function makeTargets_Sphere() {
      const vector = new THREE.Vector3();
      for (let i = 0, l = objects.length; i < l; i++) {
        const phi = Math.acos(-1 + (2 * i) / l);
        const theta = Math.sqrt(l * Math.PI) * phi;

        const obj = new THREE.Object3D();
        obj.position.setFromSphericalCoords(800, phi, theta);

        vector.copy(obj.position).multiplyScalar(2);
        obj.lookAt(vector);

        targets.sphere.push(obj);
      }
    }

    function makeTargets_DoubleHelix() {
      // FIXED: Real double helix (two smooth spirals)
      // We distribute items along "t" (height), alternating strand A/B.
      const vector = new THREE.Vector3();
      const radius = 900;
      const angleStep = 0.35;   // controls twist tightness
      const yStep = 25;         // vertical spacing

      for (let i = 0; i < objects.length; i++) {
        const strand = i % 2;            // 0 or 1
        const t = Math.floor(i / 2);    // index along height

        const theta = t * angleStep + (strand ? Math.PI : 0);
        const y = -(t * yStep) + 650;

        const obj = new THREE.Object3D();
        obj.position.setFromCylindricalCoords(radius, theta, y);

        // Face outward
        vector.set(obj.position.x * 2, obj.position.y, obj.position.z * 2);
        obj.lookAt(vector);

        targets.helix.push(obj);
      }
    }

    function makeTargets_Grid() {
      // GRID: 5 x 4 x 10 (requirement)
      for (let i = 0; i < objects.length; i++) {
        const x = (i % 5) * 400 - 800;                 // 5 columns
        const y = -(Math.floor(i / 5) % 4) * 400 + 600; // 4 rows
        const layer = Math.floor(i / 20);              // 20 per layer
        const z = layer * 1000 - 4500;                 // 10 layers approx

        const obj = new THREE.Object3D();
        obj.position.set(x, y, z);
        targets.grid.push(obj);
      }
    }

    function pointsOnTriangle(A, B, C, countNeeded) {
      // Create a triangular grid of points using barycentric coordinates
      // Pick smallest R where R*(R+1)/2 >= countNeeded
      let R = 2;
      while ((R * (R + 1)) / 2 < countNeeded) R++;

      const pts = [];
      if (R === 2) {
        pts.push(A.clone(), B.clone(), C.clone());
        return pts;
      }

      for (let r = 0; r < R; r++) {
        const u = r / (R - 1);          // 0..1
        for (let c = 0; c <= r; c++) {
          const v = (r === 0) ? 0 : (c / (R - 1));
          // ensure u+v <= 1 by using w = 1 - u - v' (we use a triangle fill style)
          // A is apex of triangle region
          const vv = c / (R - 1);
          const uu = r / (R - 1);

          // Convert to barycentric on triangle:
          // point = (1-uu)*A + (uu - vv)*B + vv*C  (keeps inside triangle)
          const wA = 1 - uu;
          const wB = uu - vv;
          const wC = vv;

          if (wB < -1e-6) continue; // safety

          const p = new THREE.Vector3()
            .addScaledVector(A, wA)
            .addScaledVector(B, wB)
            .addScaledVector(C, wC);

          pts.push(p);
          if (pts.length >= countNeeded) return pts;
        }
      }
      return pts;
    }

    function makeTargets_Tetrahedron() {
      // FIXED: True 4-face pyramid (tetrahedron). No sphere.
      // We place points on the 4 triangle faces of a regular tetrahedron.

      const size = 1400; // overall scale of tetrahedron
      const vector = new THREE.Vector3();

      // Regular tetrahedron vertices (centered), normalized then scaled
      const v0 = new THREE.Vector3( 1,  1,  1).normalize().multiplyScalar(size);
      const v1 = new THREE.Vector3( 1, -1, -1).normalize().multiplyScalar(size);
      const v2 = new THREE.Vector3(-1,  1, -1).normalize().multiplyScalar(size);
      const v3 = new THREE.Vector3(-1, -1,  1).normalize().multiplyScalar(size);

      const faces = [
        [v0, v1, v2],
        [v0, v3, v1],
        [v0, v2, v3],
        [v1, v3, v2]
      ];

      // Divide objects across 4 faces (roughly equal)
      const total = objects.length;
      const perFace = Math.ceil(total / 4);

      // Build point lists for each face
      const facePoints = faces.map(([A, B, C]) => pointsOnTriangle(A, B, C, perFace));

      // Place objects face by face
      for (let i = 0; i < total; i++) {
        const faceIndex = Math.floor(i / perFace); // 0..3
        const localIndex = i % perFace;

        const pts = facePoints[Math.min(faceIndex, 3)];
        const p = pts[Math.min(localIndex, pts.length - 1)];

        const obj = new THREE.Object3D();
        obj.position.copy(p);

        // Face outward from center
        vector.copy(p).multiplyScalar(2);
        obj.lookAt(vector);

        targets.pyramid.push(obj);
      }
    }

    function buildTargets() {
      makeTargets_Table();
      makeTargets_Sphere();
      makeTargets_DoubleHelix();
      makeTargets_Grid();
      makeTargets_Tetrahedron();
    }

    function transform(targetList, duration) {
      TWEEN.removeAll();

      for (let i = 0; i < objects.length; i++) {
        const object = objects[i];
        const target = targetList[i];
        if (!target) continue;

        new TWEEN.Tween(object.position)
          .to({ x: target.position.x, y: target.position.y, z: target.position.z },
              Math.random() * duration + duration)
          .easing(TWEEN.Easing.Exponential.InOut)
          .start();

        new TWEEN.Tween(object.rotation)
          .to({ x: target.rotation.x, y: target.rotation.y, z: target.rotation.z },
              Math.random() * duration + duration)
          .easing(TWEEN.Easing.Exponential.InOut)
          .start();
      }

      new TWEEN.Tween({})
        .to({}, duration * 2)
        .onUpdate(render)
        .start();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    }

    function animate() {
      requestAnimationFrame(animate);
      TWEEN.update();
      controls.update();
    }

    function render() {
      renderer.render(scene, camera);
    }

    // ---------- Load data + start ----------
    async function loadCSVData() {
      setStatus("Loading CSV…");
      const res = await fetch(CSV_URL, { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to load CSV. HTTP " + res.status);

      const text = await res.text();
      const rows = parseCSV(text);
      const data = rowsToObjects(rows);

      if (!data.length) throw new Error("CSV loaded but no usable rows found.");
      setStatus(`Loaded ${data.length} rows ✅`);

      return data;
    }

    function wireButtons() {
      document.getElementById('table').onclick = () => transform(targets.table, 2000);
      document.getElementById('sphere').onclick = () => transform(targets.sphere, 2000);
      document.getElementById('helix').onclick = () => transform(targets.helix, 2000);
      document.getElementById('grid').onclick = () => transform(targets.grid, 2000);
      document.getElementById('pyramid').onclick = () => transform(targets.pyramid, 2000);
    }

    (async function main() {
      try {
        initThree();
        const data = await loadCSVData();
        buildTiles(data);
        buildTargets();
        wireButtons();
        transform(targets.table, 2000);
        setStatus(`Ready ✅  (TABLE / SPHERE / HELIX / GRID / PYRAMID)`);
      } catch (e) {
        console.error(e);
        setStatus("❌ " + (e?.message || String(e)));
      }
    })();
  </script>
</body>
</html>
