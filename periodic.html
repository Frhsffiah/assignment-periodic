<!DOCTYPE html>
<html lang="en">
<head>
  <title>Assignment - Periodic (CSV Sheet Data + Pyramid)</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />

  <style>
    * { box-sizing: border-box; font-family: Helvetica, Arial, sans-serif; }
    body { margin: 0; overflow: hidden; background: #000; color: #fff; }

    #info {
      position: absolute; top: 10px; width: 100%;
      text-align: center; z-index: 2;
      user-select: none; pointer-events: none;
      opacity: 0.75; font-size: 13px;
    }

    #legend {
      position: absolute; top: 12px; left: 12px; z-index: 3;
      padding: 10px 12px; border-radius: 10px;
      border: 1px solid rgba(127,255,255,0.35);
      background: rgba(0,0,0,0.45);
      font-size: 13px; user-select: none;
    }
    #legend .r { color: #ff3b30; }
    #legend .o { color: #ff9500; }
    #legend .g { color: #34c759; }

    #container { position: absolute; inset: 0; }

    #menu {
      position: absolute; bottom: 20px; width: 100%;
      text-align: center; z-index: 3;
    }

    button {
      color: rgba(127,255,255,0.85);
      background: rgba(0,0,0,0.2);
      outline: 1px solid rgba(127,255,255,0.75);
      border: 0;
      padding: 8px 14px;
      margin: 0 6px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    button:hover { background-color: rgba(0,255,255,0.25); }
    button:active { color: #000; background-color: rgba(0,255,255,0.75); }

    /* Tiles */
    .element {
      width: 140px;
      height: 180px;
      border-radius: 12px;
      box-shadow: 0 0 12px rgba(0,255,255,0.25);
      border: 1px solid rgba(127,255,255,0.25);
      text-align: center;
      line-height: normal;
      cursor: default;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(2px);
    }
    .element:hover {
      box-shadow: 0 0 18px rgba(0,255,255,0.45);
      border: 1px solid rgba(127,255,255,0.55);
    }

    .element .number {
      position: absolute;
      top: 10px;
      right: 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.85);
      opacity: 0.9;
    }

    .element img.photo {
      position: absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      width: 54px;
      height: 54px;
      border-radius: 999px;
      object-fit: cover;
      border: 2px solid rgba(255,255,255,0.6);
      background: rgba(0,0,0,0.2);
    }

    .element .symbol {
      position: absolute;
      top: 78px;
      left: 10px;
      right: 10px;
      font-size: 16px;
      font-weight: 800;
      color: rgba(255,255,255,0.92);
      text-shadow: 0 0 10px rgba(0,0,0,0.35);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .element .details {
      position: absolute;
      bottom: 14px;
      left: 10px;
      right: 10px;
      font-size: 12px;
      color: rgba(255,255,255,0.88);
      line-height: 1.35;
      opacity: 0.95;
    }

    /* Loading overlay */
    #loadingOverlay {
      position: absolute;
      inset: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at center, rgba(0,255,255,0.06), rgba(0,0,0,0.92) 60%);
    }

    .loadingCard {
      width: min(760px, 92vw);
      padding: 26px 22px;
      border-radius: 16px;
      border: 1px solid rgba(127,255,255,0.45);
      box-shadow: 0 0 24px rgba(0,255,255,0.12);
      background: rgba(0,0,0,0.35);
      text-align: center;
    }

    .loadingCard h1 {
      margin: 0 0 10px 0;
      font-size: 40px;
      letter-spacing: 0.5px;
    }

    .loadingCard p {
      margin: 0 0 12px 0;
      color: rgba(255,255,255,0.72);
      font-size: 14px;
      line-height: 1.5;
    }

    #status {
      margin-top: 10px;
      font-size: 13px;
      color: rgba(255,255,255,0.7);
      white-space: pre-wrap;
      text-align: left;
      max-width: 720px;
      margin-left: auto;
      margin-right: auto;
    }
  </style>
</head>

<body>
  <div id="legend">
    Net Worth:
    <span class="r">Red &lt; 100K</span> |
    <span class="o">Orange 100K–200K</span> |
    <span class="g">Green &gt; 200K</span>
  </div>

  <div id="info">three.js css3d - periodic table (Public CSV data)</div>
  <div id="container"></div>

  <div id="menu">
    <button id="table">TABLE</button>
    <button id="sphere">SPHERE</button>
    <button id="helix">HELIX</button>
    <button id="grid">GRID</button>
    <button id="pyramid">PYRAMID</button>
  </div>

  <div id="loadingOverlay">
    <div class="loadingCard">
      <h1>Loading Data</h1>
      <p>Fetching your public CSV from Google Sheets and building the 3D layouts…</p>
      <div id="status">Starting…</div>
    </div>
  </div>

  <!-- IMPORTANT: Put three.module.js inside /build and jsm inside /examples/jsm -->
  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js",
        "three/addons/": "./examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import TWEEN from "three/addons/libs/tween.module.js";
    import { TrackballControls } from "three/addons/controls/TrackballControls.js";
    import { CSS3DRenderer, CSS3DObject } from "three/addons/renderers/CSS3DRenderer.js";

    // ===== YOUR PUBLIC CSV LINK (works for everyone, no login needed) =====
    const CSV_URL =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vQnfaQnOekqBUL92EWQZ2Y8dR2DT04CpSmm9m2PLzKJdO9EP5OXulbbwrEcsGSTLyVbmmZz6RXPzx9L/pub?gid=1278840914&single=true&output=csv";

    // ===== DOM =====
    const overlayEl = document.getElementById("loadingOverlay");
    const statusEl = document.getElementById("status");
    const containerEl = document.getElementById("container");

    function setStatus(msg) { statusEl.textContent = msg; }

    // ===== THREE STATE =====
    let camera, scene, renderer, controls;

    const objects = [];
    const targets = { table: [], sphere: [], helix: [], grid: [], pyramid: [] };

    // ===== Helpers =====
    function parseNetWorthToNumber(value) {
      if (!value) return 0;
      const cleaned = String(value).replace(/[^\d.]/g, "");
      const num = Number(cleaned);
      return Number.isFinite(num) ? num : 0;
    }

    function netWorthColor(netWorthNum) {
      if (netWorthNum < 100000) return "rgba(255,59,48,0.75)";      // red
      if (netWorthNum <= 200000) return "rgba(255,149,0,0.75)";     // orange
      return "rgba(52,199,89,0.75)";                                // green
    }

    // Simple CSV parser that supports commas in quotes
    function parseCSV(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];

        if (ch === '"' && inQuotes && next === '"') {
          cur += '"';
          i++;
          continue;
        }

        if (ch === '"') {
          inQuotes = !inQuotes;
          continue;
        }

        if (ch === "," && !inQuotes) {
          row.push(cur);
          cur = "";
          continue;
        }

        if ((ch === "\n" || ch === "\r") && !inQuotes) {
          if (ch === "\r" && next === "\n") i++;
          row.push(cur);
          cur = "";
          if (row.length > 1 || row[0] !== "") rows.push(row);
          row = [];
          continue;
        }

        cur += ch;
      }

      // last cell
      row.push(cur);
      if (row.length > 1 || row[0] !== "") rows.push(row);

      return rows;
    }

    function rowsToObjects(rows) {
      if (!rows.length) return [];

      const header = rows[0].map(h => String(h || "").trim().toLowerCase());

      function findIndex(names) {
        for (const n of names) {
          const idx = header.indexOf(n);
          if (idx >= 0) return idx;
        }
        return -1;
      }

      // Expect: Name, Photo, Age, Country, Interest, Net Worth
      const idx = {
        name: findIndex(["name"]),
        photo: findIndex(["photo", "image", "avatar"]),
        age: findIndex(["age"]),
        country: findIndex(["country"]),
        interest: findIndex(["interest", "hobby", "hobbies"]),
        networth: findIndex(["net worth", "networth", "net_worth"])
      };

      // fallback positions A-F
      if (idx.name < 0) idx.name = 0;
      if (idx.photo < 0) idx.photo = 1;
      if (idx.age < 0) idx.age = 2;
      if (idx.country < 0) idx.country = 3;
      if (idx.interest < 0) idx.interest = 4;
      if (idx.networth < 0) idx.networth = 5;

      const out = [];
      for (let r = 1; r < rows.length; r++) {
        const row = rows[r];
        if (!row || row.length === 0) continue;

        const name = row[idx.name] ?? "";
        if (!String(name).trim()) continue;

        const photo = row[idx.photo] ?? "";
        const age = row[idx.age] ?? "";
        const country = row[idx.country] ?? "";
        const interest = row[idx.interest] ?? "";
        const netWorthRaw = row[idx.networth] ?? "";
        const netWorthNum = parseNetWorthToNumber(netWorthRaw);

        out.push({
          name: String(name),
          photo: String(photo),
          age: String(age),
          country: String(country),
          interest: String(interest),
          netWorthRaw: String(netWorthRaw),
          netWorthNum
        });
      }
      return out;
    }

    function initThree() {
      camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.z = 3000;

      scene = new THREE.Scene();

      renderer = new CSS3DRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      containerEl.appendChild(renderer.domElement);

      controls = new TrackballControls(camera, renderer.domElement);
      controls.minDistance = 500;
      controls.maxDistance = 6000;
      controls.addEventListener("change", render);

      window.addEventListener("resize", onWindowResize);

      animate();
    }

    function clearScene() {
      for (const obj of objects) scene.remove(obj);
      objects.length = 0;
      targets.table.length = 0;
      targets.sphere.length = 0;
      targets.helix.length = 0;
      targets.grid.length = 0;
      targets.pyramid.length = 0;
    }

    function buildFromData(data) {
      clearScene();

      // 1) Create CSS3D tiles
      for (let i = 0; i < data.length; i++) {
        const d = data[i];

        const element = document.createElement("div");
        element.className = "element";
        element.style.backgroundColor = netWorthColor(d.netWorthNum);

        const number = document.createElement("div");
        number.className = "number";
        number.textContent = String(i + 1);
        element.appendChild(number);

        const img = document.createElement("img");
        img.className = "photo";
        img.alt = d.name;
        img.src = d.photo || "";
        img.onerror = () => { img.style.display = "none"; };
        element.appendChild(img);

        const symbol = document.createElement("div");
        symbol.className = "symbol";
        symbol.textContent = d.name;
        element.appendChild(symbol);

        const details = document.createElement("div");
        details.className = "details";
        details.innerHTML =
          `${d.country || "-"} | Age: ${d.age || "-"}<br>` +
          `${d.interest || "-"}<br>` +
          `${d.netWorthRaw || ""}`;
        element.appendChild(details);

        const objectCSS = new CSS3DObject(element);
        objectCSS.position.x = Math.random() * 4000 - 2000;
        objectCSS.position.y = Math.random() * 4000 - 2000;
        objectCSS.position.z = Math.random() * 4000 - 2000;
        scene.add(objectCSS);

        objects.push(objectCSS);
      }

      // 2) Targets

      // TABLE: 20 x 10
      for (let i = 0; i < objects.length; i++) {
        const col = (i % 20) + 1;
        const row = Math.floor(i / 20) + 1;

        const obj = new THREE.Object3D();
        obj.position.x = (col * 140) - 1470; // centered
        obj.position.y = -(row * 180) + 990; // centered
        targets.table.push(obj);
      }

      // SPHERE
      const vector = new THREE.Vector3();
      for (let i = 0, l = objects.length; i < l; i++) {
        const phi = Math.acos(-1 + (2 * i) / l);
        const theta = Math.sqrt(l * Math.PI) * phi;

        const obj = new THREE.Object3D();
        obj.position.setFromSphericalCoords(800, phi, theta);

        vector.copy(obj.position).multiplyScalar(2);
        obj.lookAt(vector);

        targets.sphere.push(obj);
      }

      // DOUBLE HELIX
      let pairIndex = 0;
      for (let i = 0; i < objects.length; i++) {
        const strand = i % 2;
        if (strand === 0) pairIndex++;

        const t = pairIndex * 0.35;
        const theta = t + (strand ? Math.PI : 0);
        const y = -(pairIndex * 10) + 450;

        const obj = new THREE.Object3D();
        obj.position.setFromCylindricalCoords(900, theta, y);

        vector.x = obj.position.x * 2;
        vector.y = obj.position.y;
        vector.z = obj.position.z * 2;
        obj.lookAt(vector);

        targets.helix.push(obj);
      }

      // GRID: 5 x 4 x 10
      for (let i = 0; i < objects.length; i++) {
        const x = (i % 5) * 400 - 800;
        const y = -(Math.floor(i / 5) % 4) * 400 + 600;
        const layer = Math.floor(i / 20);     // 20 items per layer
        const z = layer * 1000 - 4500;        // ~10 layers

        const obj = new THREE.Object3D();
        obj.position.set(x, y, z);
        targets.grid.push(obj);
      }

      // PYRAMID (TETRAHEDRON): 4 triangular faces
      (function buildTetrahedronTargets() {
        const v0 = new THREE.Vector3( 1,  1,  1);
        const v1 = new THREE.Vector3( 1, -1, -1);
        const v2 = new THREE.Vector3(-1,  1, -1);
        const v3 = new THREE.Vector3(-1, -1,  1);

        const S = 950;
        [v0, v1, v2, v3].forEach(v => v.normalize().multiplyScalar(S));

        const faces = [
          [v0, v1, v2],
          [v0, v3, v1],
          [v0, v2, v3],
          [v1, v3, v2]
        ];

        const total = objects.length;
        const perFaceBase = Math.floor(total / 4);
        const remainder = total % 4;

        function pointInTriangle(A, B, C, u, v) {
          const AB = new THREE.Vector3().subVectors(B, A);
          const AC = new THREE.Vector3().subVectors(C, A);
          return new THREE.Vector3()
            .copy(A)
            .add(AB.multiplyScalar(u))
            .add(AC.multiplyScalar(v));
        }

        function faceNormal(A, B, C) {
          return new THREE.Vector3()
            .subVectors(B, A)
            .cross(new THREE.Vector3().subVectors(C, A))
            .normalize();
        }

        const tempLook = new THREE.Vector3();

        for (let f = 0; f < 4; f++) {
          const A = faces[f][0], B = faces[f][1], C = faces[f][2];
          const n = faceNormal(A, B, C);
          const count = perFaceBase + (f < remainder ? 1 : 0);

          // triangular grid size k where k*(k+1)/2 >= count
          let k = 1;
          while ((k * (k + 1)) / 2 < count) k++;

          let placed = 0;
          for (let r = 0; r < k && placed < count; r++) {
            for (let c = 0; c <= r && placed < count; c++) {
              const t = (k === 1) ? 0.5 : r / (k - 1);  // 0..1
              const s = (r === 0) ? 0.5 : c / r;        // 0..1

              // barycentric inside triangle
              const u = t * (1 - s);
              const v = t * s;

              const p = pointInTriangle(A, B, C, u, v)
                .add(n.clone().multiplyScalar(40)); // push outward

              const obj = new THREE.Object3D();
              obj.position.copy(p);

              tempLook.copy(p).multiplyScalar(2);
              obj.lookAt(tempLook);

              targets.pyramid.push(obj);
              placed++;
            }
          }
        }

        // safety fill if any missing
        while (targets.pyramid.length < objects.length) {
          const obj = new THREE.Object3D();
          obj.position.set(Math.random()*200-100, Math.random()*200-100, Math.random()*200-100);
          targets.pyramid.push(obj);
        }
      })();

      // 3) Buttons
      document.getElementById("table").onclick = () => transform(targets.table, 2000);
      document.getElementById("sphere").onclick = () => transform(targets.sphere, 2000);
      document.getElementById("helix").onclick = () => transform(targets.helix, 2000);
      document.getElementById("grid").onclick = () => transform(targets.grid, 2000);
      document.getElementById("pyramid").onclick = () => transform(targets.pyramid, 2000);

      // default
      transform(targets.table, 2000);
      render();
    }

    function transform(targetList, duration) {
      TWEEN.removeAll();

      for (let i = 0; i < objects.length; i++) {
        const object = objects[i];
        const target = targetList[i];
        if (!target) continue;

        new TWEEN.Tween(object.position)
          .to({ x: target.position.x, y: target.position.y, z: target.position.z }, Math.random() * duration + duration)
          .easing(TWEEN.Easing.Exponential.InOut)
          .start();

        new TWEEN.Tween(object.rotation)
          .to({ x: target.rotation.x, y: target.rotation.y, z: target.rotation.z }, Math.random() * duration + duration)
          .easing(TWEEN.Easing.Exponential.InOut)
          .start();
      }

      new TWEEN.Tween(this)
        .to({}, duration * 2)
        .onUpdate(render)
        .start();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    }

    function animate() {
      requestAnimationFrame(animate);
      TWEEN.update();
      controls.update();
    }

    function render() {
      renderer.render(scene, camera);
    }

    // ===== Start =====
    async function main() {
      initThree();

      try {
        setStatus("Fetching CSV…");
        const res = await fetch(CSV_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`CSV fetch failed: ${res.status} ${res.statusText}`);
        const text = await res.text();

        setStatus("Parsing CSV…");
        const rows = parseCSV(text);
        const data = rowsToObjects(rows);

        if (!data.length) {
          throw new Error("No rows found. Make sure your CSV has Name, Photo, Age, Country, Interest, Net Worth.");
        }

        setStatus(`Loaded ${data.length} rows.\nBuilding 3D layouts…`);
        buildFromData(data);

        overlayEl.style.display = "none";
      } catch (err) {
        console.error(err);
        setStatus("❌ " + (err?.message || String(err)));
      }
    }

    main();
  </script>
</body>
</html>
